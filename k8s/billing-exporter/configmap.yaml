apiVersion: v1
kind: ConfigMap
metadata:
  name: billing-exporter-config
  namespace: monitoring
  labels:
    app.kubernetes.io/name: billing-exporter
    app.kubernetes.io/part-of: mimir-observability
data:
  exporter.py: |
    #!/usr/bin/env python3
    import json
    import os
    import ssl
    import sys
    import time
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib import request, parse, error

    QUERY_ENDPOINT = os.environ.get("QUERY_ENDPOINT", "https://mimir-query-frontend.monitoring.svc.cluster.local/prometheus/api/v1/query")
    QUERY_TENANT = os.environ.get("QUERY_TENANT", "system")
    CA_FILE = os.environ.get("CA_CERT_PATH", "/etc/mimir-ca/ca.crt")
    LISTEN_ADDRESS = os.environ.get("LISTEN_ADDRESS", "0.0.0.0")
    LISTEN_PORT = int(os.environ.get("LISTEN_PORT", "9105"))
    TIMEOUT = float(os.environ.get("QUERY_TIMEOUT", "5"))

    QUERIES = {
        "billing_active_series": "sum by (tenant) (cortex_ingester_active_series)",
        "billing_samples_per_second": "sum by (tenant) (rate(cortex_ingester_ingested_samples_total[5m]))",
        "billing_query_bytes": "sum by (tenant) (rate(cortex_query_frontend_received_bytes_total[5m]))",
        "billing_query_seconds": "sum by (tenant) (rate(cortex_query_frontend_query_duration_seconds_sum[5m]))",
    }

    headers = {
        "X-Scope-OrgID": QUERY_TENANT,
    }

    if os.path.exists(CA_FILE):
        SSL_CONTEXT = ssl.create_default_context(cafile=CA_FILE)
    else:
        SSL_CONTEXT = ssl.create_default_context()

    def run_query(expr: str):
        params = parse.urlencode({"query": expr})
        url = f"{QUERY_ENDPOINT}?{params}"
        req = request.Request(url, headers=headers)
        with request.urlopen(req, timeout=TIMEOUT, context=SSL_CONTEXT) as resp:
            payload = resp.read().decode("utf-8")
        data = json.loads(payload)
        if data.get("status") != "success":
            raise RuntimeError(f"Query failed: {payload}")
        return data["data"]["result"]

    def line(metric: str, labels: dict, value: float) -> str:
        label_parts = [f'{k}="{v}"' for k, v in sorted(labels.items())]
        label_str = "{" + ",".join(label_parts) + "}" if label_parts else ""
        return f"{metric}{label_str} {value}"

    class Handler(BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path not in ("/metrics", "/metrics/"):
                self.send_response(404)
                self.end_headers()
                self.wfile.write(b"not found")
                return
            metrics = [
                "# HELP billing_active_series Active series per tenant observed in ingesters.",
                "# TYPE billing_active_series gauge",
                "# HELP billing_samples_per_second Samples ingested per tenant per second.",
                "# TYPE billing_samples_per_second gauge",
                "# HELP billing_query_bytes Query bytes processed per tenant per second.",
                "# TYPE billing_query_bytes gauge",
                "# HELP billing_query_seconds Query time spent per tenant per second.",
                "# TYPE billing_query_seconds gauge",
            ]
            now = time.time()
            try:
                for metric_name, prom_expr in QUERIES.items():
                    result = run_query(prom_expr)
                    for sample in result:
                        labels = sample.get("metric", {})
                        tenant = labels.get("tenant") or labels.get("user") or "unknown"
                        value = float(sample["value"][1])
                        metrics.append(line(metric_name, {"tenant": tenant}, value))
                metrics.append("# HELP billing_exporter_last_scrape_timestamp_seconds Timestamp of the last successful scrape.")
                metrics.append("# TYPE billing_exporter_last_scrape_timestamp_seconds gauge")
                metrics.append(line("billing_exporter_last_scrape_timestamp_seconds", {}, now))
                self.send_response(200)
                self.send_header("Content-Type", "text/plain; version=0.0.4")
                self.end_headers()
                self.wfile.write("\n".join(metrics).encode("utf-8"))
            except Exception as exc:
                sys.stderr.write(f"scrape failed: {exc}\n")
                self.send_response(500)
                self.end_headers()
                self.wfile.write(f"error {exc}".encode("utf-8"))

        def log_message(self, format, *args):
            return

    if __name__ == "__main__":
        httpd = HTTPServer((LISTEN_ADDRESS, LISTEN_PORT), Handler)
        print(f"billing exporter listening on {LISTEN_ADDRESS}:{LISTEN_PORT}", flush=True)
        httpd.serve_forever()
